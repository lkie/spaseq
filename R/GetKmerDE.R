#' Calculates differential abundunce of kmers 
#'
#' Function uses edgeR package to calculate differences 
#' between abundunces of kmers at different positions of the probed construct.
#'
#' @param all_kmers List structure of counts of kmers at different position 
#' generated by \code{\link{importKmers}}
#' @param samples A table with the description of samples. Guides the function 
#' on what to compare to what.
#' @return DEresults - Multi-level list structure. The first level are different 
#' enzymes, the second level are different constructs,
#' the third level is kmer length, 
#' the fourth level is kmer starting position within a construct, 
#' and the fifth level is a type of information for each kmer: 
#' (a) logFC - log2 fold change, 
#' (b) PValue - p-value that the abundunce has significantly changed
#' (c) logCPM - log2 counts-per-million  
#' (d) pi_value - pi-value, defined as -log10(p-value)*(fold change) (see Xiao Y et al. 2012)
#' which contain a vector of a values for different kmers (sorted alphabetically)
#' @author Lukasz Jan Kielpinski
#' @seealso \code{\link{importKmers}}
#' @references Robinson, Mark D., Davis J. McCarthy, and Gordon K. Smyth. 2010. 
#' “edgeR: A Bioconductor Package for Differential Expression Analysis of 
#' Digital Gene Expression Data.” Bioinformatics (Oxford, England) 26 (1):
#' 139–40. doi:10.1093/bioinformatics/btp616.
#' @references Xiao, Yufei, Tzu-Hung Hsiao, Uthra Suresh, Hung-I. Harry Chen, 
#' Xiaowu Wu, Steven E. Wolf, and Yidong Chen. 2014. “A Novel Significance 
#' Score for Gene Selection and Ranking.” Bioinformatics (Oxford, England) 
#' 30 (6): 801–7. doi:10.1093/bioinformatics/btr671.
#' @import edgeR
#' @export GetKmerDE
 
GetKmerDE <- function(all_kmers, samples){
  usedEnzymes <- sort(unique(samples$enzyme))
  DEresults <- list()
  for(enzyme in usedEnzymes){
    DEresults[[enzyme]] <- list()
    constructs <- sort(unique(samples$construct[samples$enzyme == enzyme]))
    for(constr in constructs){
      DEresults[[enzyme]][[constr]] <- list()
      insertLength <- ncol(all_kmers[[constr]][[samples[samples$enzyme == enzyme & samples$construct == constr, "index"][1]]][[1]])
      maxKmerLen <- length(all_kmers[[constr]][[samples[samples$enzyme == enzyme & samples$construct == constr, "index"][1]]])
      for(kmerLen in 1:maxKmerLen){
        DEresults[[enzyme]][[constr]][[kmerLen]] <- list()
        for(pos in 1:(insertLength - kmerLen + 1)){
          localSamples <- samples$enzyme == enzyme & samples$construct == constr
          localIndices <- samples$index[localSamples]

          localMatrix <- matrix(nrow = 4**kmerLen, ncol = 1)
          for(index in localIndices){
            localMatrix <- cbind(localMatrix, all_kmers[[constr]][[index]][[kmerLen]][,pos])
          }
          localMatrix <- localMatrix[, -1]
          
          dL <- DGEList(localMatrix,
                        group = samples$treated[localSamples] + 1) # '+ 1' if to change from FALSE/TRUE to 1/2
          dL <- estimateCommonDisp(dL)
          edgeR_test <- exactTest(estimateTagwiseDisp(dL), dispersion = "tagwise")
          #Save the results to the list structure:
          DEresults[[enzyme]][[constr]][[kmerLen]][[pos]] <- list()
          DEresults[[enzyme]][[constr]][[kmerLen]][[pos]][["logFC"]] <- edgeR_test$table$logFC
          DEresults[[enzyme]][[constr]][[kmerLen]][[pos]][["PValue"]] <- edgeR_test$table$PValue
          DEresults[[enzyme]][[constr]][[kmerLen]][[pos]][["logCPM"]] <- edgeR_test$table$logCPM
          DEresults[[enzyme]][[constr]][[kmerLen]][[pos]][["pi_value"]] <- -log10(edgeR_test$table$PValue)*2**abs(edgeR_test$table$logFC)
        }
      }
    }
  }
  DEresults
}

